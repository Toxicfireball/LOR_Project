{% extends "base.html" %}
{% block title %}Create Character – Stage 1{% endblock %}
{% block content %}





<style>
  /* Global styles */
  body { background-color: #f4f4f4; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; color: #333; margin: 0; padding: 0; line-height: 1.6; }
  form#characterForm { max-width: 900px; margin: 20px auto; padding: 20px; background-color: #fff; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,.1); }
  /* Global styles */
  body {
    background-color: #f4f4f4;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    color: #333;
    margin: 0;
    padding: 0;
    line-height: 1.6;
  }

  /* Container and form layout */
  form#characterForm {
    max-width: 900px;
    margin: 20px auto;
    padding: 20px;
    background-color: #fff;
    border: 1px solid #ddd;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  /* Headings */
  h2, h3 {
    text-align: center;
    margin-top: 0;
  }

  /* Section containers */
  div.section {
    background-color: #eef;
    padding: 15px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  div.section.light {
    background-color: #f9f9f9;
  }

  /* Labels and inputs */
  label {
    display: block;
    margin-top: 10px;
    font-weight: bold;
  }
  input[type="text"],
  input[type="number"],
  select,
  textarea {
    width: 100%;
    padding: 8px;
    margin-top: 5px;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
  }

  /* Buttons */
  button {
    background-color: #007BFF;
    color: #fff;
    border: none;
    padding: 10px 20px;
    margin-top: 10px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 1rem;
  }
  button:hover {
    background-color: #0056b3;
  }
  button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  /* Inline form sections */
  #subrace-container,
  #racial-allocation-section,
  #half-elf-origin-container {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #eef;
  }

  /* Stats table */
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
  }
  table th, table td {
    padding: 8px;
    border: 1px solid #ccc;
    text-align: center;
  }
  table th {
    background-color: #eee;
  }

  /* Textarea for backstory */
  textarea {
    resize: vertical;
  }

  /* Centering final submit button */
  form#characterForm > div[style*="text-align:center"] {
    margin-top: 20px;
  }

</style>

<h2 style="text-align:center;">Stage 1: Basic Character Creation</h2>
<p style="text-align:center;">Enter your character’s name, choose your race (and subrace if available) and background, provide a backstory, and adjust your ability scores using the point-buy system.</p>

<form method="post" id="characterForm" style="max-width:900px; margin: 0 auto; border:1px solid #ddd; padding:20px; background:#fff;">
  {% csrf_token %}

  <!-- Basic Info -->
  <div style="background:#f9f9f9; padding:15px; margin-bottom:20px; border:1px solid #ddd;">
    <label for="name">Character Name:</label>
    <input type="text" name="name" id="name" required>

    <!-- ability score table -->
    <div class="container" style="border:1px solid #ddd; padding:15px; background:#f9f9f9; margin-bottom:20px;">
      <h2>Add Ability Scores</h2>
      <div id="score-section">
        <h3>Add in Order: Point Buy &gt; Race &gt; Background &gt; Boost</h3>
        <p><strong>Point Buy Remaining:</strong> <span id="points-remaining">12</span></p>
        <p><strong>Background Modifier Total:</strong> <span id="background-total">0</span> / 3 <button type="button" onclick="resetBackground()">Reset Background</button></p>
        <p><strong>Boost Slots Remaining:</strong> <span id="boosts-remaining">5</span> <button type="button" onclick="resetBoosts()">Reset Boosts</button></p>
        <h3>Adjust Base Scores (Point Buy)</h3>
        <table><thead><tr><th>Ability</th><th>Base Score (8–13)</th><th>Race Mod</th><th>Background Mod</th><th>Boost Mod</th><th>Final Value</th></tr></thead>
          <tbody id="stat-table"></tbody>
        </table>
        <button type="button" onclick="resetCharacter()">Reset All</button>
      </div>
    </div>

    <!-- Race & Subrace -->
    <label for="race">Race:</label>
    <select name="race" id="race" required>
      <option value="">-- Select a Race --</option>
    </select>

    <div id="subrace-container" style="display:none; margin-top:10px;">
      <label for="subrace">Subrace:</label>
      <select name="subrace" id="subrace" style="width:100%; padding:8px;"></select>
    </div>

    <!-- Racial allocation -->
    <div id="racial-allocation-section" style="display:none; border:1px solid #ddd; padding:10px; background:#eef; margin-top:10px;">
      <h3>Allocate Your Racial Bonus Points</h3>
      <p>You have <span id="racial-points"></span> bonus point(s) to allocate among your abilities.</p>
      <div style="display:flex; flex-wrap:wrap; gap:10px;">
        <label>Strength: <input type="number" id="racial-strength" value="0" min="0" max="1" style="width:50px;"></label>
        <label>Dexterity: <input type="number" id="racial-dexterity" value="0" min="0" max="1" style="width:50px;"></label>
        <label>Constitution: <input type="number" id="racial-constitution" value="0" min="0" max="1" style="width:50px;"></label>
        <label>Intelligence: <input type="number" id="racial-intelligence" value="0" min="0" max="1" style="width:50px;"></label>
        <label>Wisdom: <input type="number" id="racial-wisdom" value="0" min="0" max="1" style="width:50px;"></label>
        <label>Charisma: <input type="number" id="racial-charisma" value="0" min="0" max="1" style="width:50px;"></label>
      </div>
      <button type="button" onclick="applyRacialAllocation()">Apply Racial Bonuses</button>
    </div>

    <!-- Half-elf origin -->
    <div id="half-elf-origin-container" style="display:none; border:1px solid #ddd; padding:10px; background:#eef; margin-top:10px;">
      <h3>Choose Your Half-Elf Origin</h3>
      <p>Select one of the following: High Elf (+1 Int), Wood Elf (+1 Wis), or Dark Elf (+1 Cha).</p>
      <select id="half-elf-origin" name="half_elf_origin" disabled style="width:100%; padding:8px;">
        <option value="high">High Elf</option>
        <option value="wood">Wood Elf</option>
        <option value="dark">Dark Elf</option>
      </select>
    </div>
  </div>

  <!-- Backgrounds -->
  <div class="section">
    <h3>Background Combination</h3>
    <label><input type="radio" name="bg_combo" value="0" checked> Main Background Only</label>
    <label><input type="radio" name="bg_combo" value="1"> Main + 1 Side Background</label>
    <label><input type="radio" name="bg_combo" value="2"> Main + 2 Side Backgrounds</label>
  </div>
  
  <div class="section">
    <h3>Main Background</h3>
    <label for="main_background">Select Main Background:</label>
    <select id="main_background" style="width:100%; padding:8px;">
      <option value="">-- Select Main Background --</option>
    </select>
    <p>(In Main-only mode, you get both primary (+2) and secondary (+1) benefits.)</p>
  </div>

  <div id="side_bg1_container" class="section" style="display:none;">
    <h3>Side Background 1</h3>
    <label for="side_background_1">Select Side Background 1:</label>
    <select id="side_background_1" style="width:100%; padding:8px;"><option value="">-- Select Side Background --</option></select>
    <div id="side_bg1_fields" style="margin-top:10px;"></div>
  </div>

  <div id="side_bg2_container" class="section" style="display:none;">
    <h3>Side Background 2</h3>
    <label for="side_background_2">Select Side Background 2:</label>
    <select id="side_background_2" style="width:100%; padding:8px;"><option value="">-- Select Side Background --</option></select>
    <div id="side_bg2_fields" style="margin-top:10px;"></div>
  </div>
  

  <div style="margin-top:1rem;">
    <h4>Background Skill Proficiencies</h4>
    <div id="background-skill-display">
      No skill proficiencies allocated yet.
    </div>
  </div>
  <!-- Hidden fields for JS to write into -->
  <input type="hidden" name="final_race" id="finalRace" value="">
  <input type="hidden" name="strength" id="strengthInput" value="8">
  <input type="hidden" name="dexterity" id="dexterityInput" value="8">
  <input type="hidden" name="constitution" id="constitutionInput" value="8">
  <input type="hidden" name="intelligence" id="intelligenceInput" value="8">
  <input type="hidden" name="wisdom" id="wisdomInput" value="8">
  <input type="hidden" name="charisma" id="charismaInput" value="8">
  <input type="hidden" name="computed_skill_proficiencies" id="computed_skill_proficiencies" value="{}">

  <!-- Backstory -->
  <div style="margin-bottom:20px;"><label for="backstory">Backstory:</label><textarea name="backstory" id="backstory" rows="4"></textarea></div>

  <div style="text-align:center;"><button type="submit">Finish Stage 1 &amp; Create Character</button></div>
</form>

<script>
  const races              = {{ races_json|safe }};
  const backgrounds        = {{ backgrounds_json|safe }};

  // first declare our three lookups
  const racialModifiersDict = {};
  const customizableRaces   = {};
  const subracesDict        = {};

  // now populate them from the JSON
  races.forEach(r => {
    // flat ability bonuses
    racialModifiersDict[r.code] = r.modifiers;

    // how many free points that race gets
    if (r.free_points > 0) {
      customizableRaces[r.code] = r.free_points;
    }

    // build a subrace array, if any
    if (Array.isArray(r.subraces) && r.subraces.length) {
      subracesDict[r.code] = r.subraces.map(sr => ({
        value: sr.code,
        label: sr.name
      }));
    }
  });

document.addEventListener("DOMContentLoaded", function() {
  // Global state
  const stats = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"];
  let baseStats = {}, raceModifiers = {}, backgroundModifiers = {}, boostModifiers = {};
  let pointsRemaining = 12, boostsRemaining = 5;
  let boostedStats = {};
  let step = 1; // 1 = Point Buy, 2 = Race, 3 = Background, 4 = Boosts
  let highBoostedUsed = false, asiApplied = 0;
  let bgAbilityBonuses = {}, bgSkillProficiencies = {};
  let racialASIBonus = { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
  let racialASIPoints = 0;
    const mainBg    = document.getElementById("main_background");
  const sideBg1   = document.getElementById("side_background_1");
  const sideBg2   = document.getElementById("side_background_2");
  
    const raceEl           = document.getElementById('race');
    const subraceEl        = document.getElementById('subrace');
    const subraceContainer = document.getElementById('subrace-container');
    const mainBgEl         = document.getElementById('main_background');
    const sideBg1El        = document.getElementById('side_background_1');
    const sideBg2El        = document.getElementById('side_background_2');
    // …declare all your state variables here…

    // 2) populate Race dropdown
    races.forEach(r => {
      const opt = document.createElement('option');
      opt.value = r.code;
      opt.text  = r.name;
      raceEl.appendChild(opt);
    });

    // 3) on Race change → build subraces
    raceEl.addEventListener('change', () => {
      subraceEl.innerHTML = '<option value="">-- Select a Subrace --</option>';
      const sel = races.find(r => r.code === raceEl.value);
      if (sel && sel.subraces.length) {
        sel.subraces.forEach(sr => {
          const o = document.createElement('option');
          o.value = sr.code;
          o.text  = sr.name;
          subraceEl.appendChild(o);
        });
        subraceContainer.style.display = '';
      } else {
        subraceContainer.style.display = 'none';
      }
      // reset downstream steps…
    });
    

    // 4) populate Background dropdowns
    backgrounds.forEach(b => {
      [ mainBgEl, sideBg1El, sideBg2El ].forEach(el => {
        const opt = document.createElement('option');
        opt.value = b.code;
        opt.text  = b.name;
        el.appendChild(opt);
      });
    });

  // Fixed racial modifiers dictionary.


  function updateSideBG2Fields() {
  const side2Type = document.querySelector('input[name="side2_bonus_type"]:checked').value;
  if (side2Type === "ability") {
    document.getElementById("side_bg2_ability_fields").style.display = "block";
    document.getElementById("side_bg2_skill_fields").style.display = "none";
  } else {
    document.getElementById("side_bg2_ability_fields").style.display = "none";
    document.getElementById("side_bg2_skill_fields").style.display = "block";
  }
}

  // Initialize character data.
  function initializeCharacter() {
    stats.forEach(stat => {
      baseStats[stat] = 8;
      raceModifiers[stat] = 0;
      backgroundModifiers[stat] = 0;
      boostModifiers[stat] = 0;
      boostedStats[stat] = false;
    });
    pointsRemaining = 12;
    boostsRemaining = 5;
    step = 1;
    highBoostedUsed = false;
    asiApplied = 0;
    updateDisplay();
  }
  initializeCharacter();

  // Reset functions
  function resetStagesFrom(stage) {
    if (stage <= 2) {
      stats.forEach(stat => backgroundModifiers[stat] = 0);
      document.getElementById("side_background_1").value = "";
      document.getElementById("side_background_2").value = "";
      step = 2;
    }
    if (stage <= 3) {
      stats.forEach(stat => {
        boostModifiers[stat] = 0;
        boostedStats[stat] = false;
      });
      boostsRemaining = 5;
      highBoostedUsed = false;
      step = 3;
    }
    updateDisplay();
  }
  function resetBoosts() { resetStagesFrom(3); }
  function resetBackground() { resetStagesFrom(2); }
  function resetCharacter() { initializeCharacter(); }

  // Point buy adjustment
  function adjustStat(stat, amount) {
    if (step !== 1) return;
    if (amount === 1 && pointsRemaining > 0 && baseStats[stat] < 13) {
      baseStats[stat]++;
      pointsRemaining--;
    } else if (amount === -1 && baseStats[stat] > 8) {
      baseStats[stat]--;
      pointsRemaining++;
    }
    updateDisplay();
  }

  // Background helpers
  function resetBackgroundState() {
    bgAbilityBonuses = { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
    bgSkillProficiencies = {};
  }
  function addAbilityBonus(ability, bonus) {
    bgAbilityBonuses[ability] = Math.min((bgAbilityBonuses[ability] || 0) + bonus, 2);
  }
  function addSkill(skillName) {
  if (!skillName) return;
  // Only “Trained” once—no stacking
  bgSkillProficiencies[skillName] = 1;
}

  function updateBackgroundSummary() {
    let summary = "<h4>Ability Bonuses from Backgrounds:</h4>";
    for (let ability in bgAbilityBonuses) {
      if (bgAbilityBonuses[ability] > 0) {
        summary += `<strong>${ability}</strong>: +${bgAbilityBonuses[ability]}<br>`;
      }
    }
    summary += "<h4>Skill Proficiencies from Backgrounds:</h4>";
    for (let skill in bgSkillProficiencies) {
  summary += `<strong>${skill}</strong>: Trained<br>`;
}

  }
  function updateBackgroundModifiers() {
    resetBackgroundState();
    const combo = document.querySelector('input[name="bg_combo"]:checked').value;
    const mainKey = document.getElementById("main_background").value;
    if (!mainKey || !backgrounds[mainKey]) return;
    const mainBG = backgrounds[mainKey];
    if (combo === "0") {
  // only primary +2, never the +1
  addAbilityBonus(mainBG.primary.ability, mainBG.primary.bonus);
  // (no secondary)
  addSkill(mainBG.primary.skill);
}
 else {
      addAbilityBonus(mainBG.primary.ability, mainBG.primary.bonus);
      addSkill(mainBG.primary.skill);
      if (combo === "1") {
  // 1) Main Background: Primary only (+2 & primary skill)
  addAbilityBonus(mainBG.primary.ability, mainBG.primary.bonus);
  addSkill(mainBG.primary.skill);

  // 2) Side Background: exactly one ability (+1) and one skill
  const sideKey = document.getElementById("side_background_1").value;
  if (sideKey && backgrounds[sideKey]) {
    // Ability: from primary or secondary, but max +1
    const abilityChoice = document.getElementById("side_bg1_ability_choice").value;
    addAbilityBonus(backgrounds[sideKey][abilityChoice].ability, 1);

    // Skill: from primary or secondary
    const skillChoice = document.getElementById("side_bg1_skill_choice").value;
    addSkill(backgrounds[sideKey][skillChoice].skill);
  }
}



if (combo === "2") {
  // 1) Main: Primary only
  addAbilityBonus(mainBG.primary.ability, mainBG.primary.bonus);
  addSkill(mainBG.primary.skill);

  // 2) Two Sides: one ability (+1) from either side, one skill from the other
  //    Choice radios determine which side gives which benefit.

  // Determine which side gives the ability bonus:
  const abilitySide = document.querySelector('input[name="sideAbilityForTwo"]:checked').value;
  const skillSide   = abilitySide === 'side1' ? 'side2' : 'side1';

  // Side X: ability
  const sideAbilityKey = document.getElementById(abilitySide === 'side1'
    ? 'side_background_1'
    : 'side_background_2').value;
  if (sideAbilityKey) {
    const elem = abilitySide === 'side1'
      ? document.getElementById('side_bg1_ability_choice')
      : document.getElementById('side_bg2_ability_choice');
    addAbilityBonus(backgrounds[sideAbilityKey][elem.value].ability, 1);
  }

  // Side Y: skill
  const sideSkillKey = document.getElementById(skillSide === 'side1'
    ? 'side_background_1'
    : 'side_background_2').value;
  if (sideSkillKey) {
    const elem = skillSide === 'side1'
      ? document.getElementById('side_bg1_skill_choice')
      : document.getElementById('side_bg2_skill_choice');
    addSkill(backgrounds[sideSkillKey][elem.value].skill);
  }
}

    }
    backgroundModifiers = Object.assign({}, bgAbilityBonuses);
    updateBackgroundSummary();
  }

  function updateBackgroundSkillProficiencies() {
    let skillMap = {};
    function addSkillLocal(skillName) {
      if (!skillName) return;
      skillMap[skillName] = Math.min((skillMap[skillName] || 0) + 1, 2);
    }
    const mainBGKey = document.getElementById("main_background").value;
    const combo = document.querySelector('input[name="bg_combo"]:checked').value;
    if (mainBGKey && backgrounds[mainBGKey]) {
      let mainBG = backgrounds[mainBGKey];
      if (combo === "0") {
        addSkillLocal(mainBG.primary.skill);
        addSkillLocal(mainBG.secondary.skill);
      } else {
        addSkillLocal(mainBG.primary.skill);
      }
    }
    if (combo === "1") {
  const side1Key = document.getElementById("side_background_1").value;
  if (side1Key && backgrounds[side1Key]) {
    const side1Type = document.querySelector('input[name="side1_bonus_type_combo2"]:checked')?.value;
    if (side1Type === "skill") {
      const sideBg1SkillElem = document.getElementById("side_bg1_skill_choice");
      const skillChoice = sideBg1SkillElem ? sideBg1SkillElem.value : "";
      if (skillChoice !== "primary" && skillChoice !== "secondary") {
        console.error("Invalid skill choice for Side BG 1 in skill proficiencies:", skillChoice);
      } else if (backgrounds[side1Key][skillChoice]) {
        addSkillLocal(backgrounds[side1Key][skillChoice].skill);
      } else {
        console.error("No valid backgrounds entry for", side1Key, "with key", skillChoice);
      }
    }
  }
}


    if (combo === "2") {
      const side1Key = document.getElementById("side_background_1").value;
      if (side1Key && backgrounds[side1Key]) {
        const side1Type = document.querySelector('input[name="side1_bonus_type_combo2"]:checked')?.value;
        if (side1Type === "skill") {
          const sideBg1SkillElem = document.getElementById("side_bg1_skill_choice");
         const skillChoice = sideBg1SkillElem ? sideBg1SkillElem.value : "";
          addSkillLocal(backgrounds[side1Key][skillChoice].skill);
        }
      }
      const side2Key = document.getElementById("side_background_2").value;
if (side2Key && backgrounds[side2Key]) {
  const side2Type = document.querySelector('input[name="side2_bonus_type"]:checked').value;
  if (side2Type === "ability") {
  let abilityChoice = "";
  const abilityElem2 = document.getElementById("side_bg2_ability_choice");
  if (abilityElem2) {
    abilityChoice = abilityElem2.value;
  } else {
    console.error("Element 'side_bg2_ability_choice' not found for Side BG 2. Defaulting to 'primary'.");
    abilityChoice = "primary";
  }
  if (backgrounds[side2Key] && backgrounds[side2Key][abilityChoice]) {
    addAbilityBonus(backgrounds[side2Key][abilityChoice].ability, 1);
  } else {
    console.error("Invalid ability choice for Side BG 2:", abilityChoice);
  }
} else {
  const sideBg2SkillElem = document.getElementById("side_bg2_skill_choice");
  let skillChoice = sideBg2SkillElem ? sideBg2SkillElem.value : "";
  if (skillChoice !== "primary" && skillChoice !== "secondary") {
    console.error("Invalid skill choice for Side BG 2:", skillChoice);
  } else if (backgrounds[side2Key] && backgrounds[side2Key][skillChoice]) {
    addSkill(backgrounds[side2Key][skillChoice].skill);
  } else {
    console.error("No valid backgrounds entry for", side2Key, "with key", skillChoice);
  }
}

}
    }

    let text = "";
    Object.keys(skillMap).forEach(skillName => {
      text += `<strong>${skillName}</strong>: ${skillMap[skillName]} proficiency<br>`;
    });
    if (!text) text = "No skill proficiencies allocated yet.";
    document.getElementById("background-skill-display").innerHTML = text;
  }

  function setupSideBG1ForCombo2() {
    const container = document.getElementById("side_bg1_fields");
    container.innerHTML = `
      <p>Choose bonus type for Side BG 1:</p>
      <label>
        <input type="radio" name="side1_bonus_type_combo2" value="ability" checked> Ability Bonus (+1)
      </label>
      <label>
        <input type="radio" name="side1_bonus_type_combo2" value="skill"> Skill Proficiency
      </label>
      <div id="side_bg1_ability_fields" class="bonus-detail" style="display:block;">
        <label for="side_bg1_ability_choice">Choose bonus (Primary or Secondary):</label>
        <select id="side_bg1_ability_choice">
          <option value="primary">Primary (normally +2, counts as +1)</option>
          <option value="secondary">Secondary (+1)</option>
        </select>
      </div>
      <div id="side_bg1_skill_fields" class="bonus-detail" style="display:none;">
        <label for="side_bg1_skill_choice">Choose which skill (Primary or Secondary):</label>
        <select id="side_bg1_skill_choice">
          <option value="primary">Primary Skill</option>
          <option value="secondary">Secondary Skill</option>
        </select>
      </div>
    `;
    document.querySelectorAll('input[name="side1_bonus_type_combo2"]').forEach(radio => {
      radio.addEventListener("change", function() {
        if (this.value === "ability") {
          document.getElementById("side_bg1_ability_fields").style.display = "block";
          document.getElementById("side_bg1_skill_fields").style.display = "none";
        } else {
          document.getElementById("side_bg1_ability_fields").style.display = "none";
          document.getElementById("side_bg1_skill_fields").style.display = "block";
        }
        updateBackgroundModifiers();
      });
    });
  }

  function validateSideBackgroundBonusTypes() {
    const bgCombo = parseInt(document.querySelector('input[name="bg_combo"]:checked').value, 10);
    if (bgCombo === 2) {
      const side1Type = document.querySelector('input[name="side1_bonus_type_combo2"]:checked')?.value;
      const side2Type = document.querySelector('input[name="side2_bonus_type"]:checked')?.value;
      if (side1Type === side2Type) {
        alert("For two side backgrounds, one must supply an ability bonus and the other a skill proficiency.");
        return false;
      }
    }
    return true;
  }

  // Racial and Background Dropdown listeners
  document.getElementById("race").addEventListener("change", function() {
    const selectedMainRace = this.value;
    const subraceContainer = document.getElementById("subrace-container");
    if (subracesDict[selectedMainRace]) {
      subraceContainer.style.display = "block";
      const subraceSelect = document.getElementById("subrace");
      subraceSelect.innerHTML = "";
      subracesDict[selectedMainRace].forEach(option => {
        let opt = document.createElement("option");
        opt.value = option.value;
        opt.text = option.label;
        subraceSelect.appendChild(opt);
      });
      subraceSelect.value = "";
    } else {
      subraceContainer.style.display = "none";
    }
    resetStagesFrom(2);
    updateHalfElfOriginDisplay();
    checkForCustomizable();
    updateDisplay();
  });

  document.getElementById("subrace").addEventListener("change", function() {
    currentRacialModifiers = racialModifiersDict[this.value] || { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
    updateHalfElfOriginDisplay();
    checkForCustomizable();
    updateDisplay();
  });

  document.getElementById("half-elf-origin").addEventListener("change", updateDisplay);

  document.getElementById("main_background").addEventListener("change", function() {
    const side1Value = document.getElementById("side_background_1").value;
    const side2Value = document.getElementById("side_background_2").value;
    if (this.value === side1Value && this.value !== "") {
      alert("Main Background cannot be the same as Side Background 1.");
      this.value = "";
    } else if (this.value === side2Value && this.value !== "") {
      alert("Main Background cannot be the same as Side Background 2.");
      this.value = "";
    }
    resetStagesFrom(3);
    updateBackgroundSkillProficiencies();
    updateDisplay();
  });

  document.getElementById("side_background_1").addEventListener("change", function() {
    const mainValue = document.getElementById("main_background").value;
    if (this.value === mainValue && this.value !== "") {
      alert("Side Background 1 cannot be the same as Main Background.");
      this.value = "";
      updateBackgroundSkillProficiencies();
      updateDisplay();
      resetStagesFrom(3);
      return;
    }
    const side2Value = document.getElementById("side_background_2").value;
    if (this.value === side2Value && this.value !== "") {
      alert("Please select a different side background. You cannot choose the same background twice.");
      this.value = "";
      updateBackgroundSkillProficiencies();
      updateDisplay();
      resetStagesFrom(3);
    }
  });

  document.getElementById("side_background_2").addEventListener("change", function() {
    const mainValue = document.getElementById("main_background").value;
    if (this.value === mainValue && this.value !== "") {
      alert("Side Background 2 cannot be the same as Main Background.");
      this.value = "";
      updateBackgroundSkillProficiencies();
      updateDisplay();
      return;
    }
    const side1Value = document.getElementById("side_background_1").value;
    if (this.value === side1Value && this.value !== "") {
      alert("Please select a different side background. You cannot choose the same background twice.");
      this.value = "";
      updateBackgroundSkillProficiencies();
      updateDisplay();
    }
  });

  // Side BG 2 radio buttons
  document.querySelectorAll('input[name="side2_bonus_type"]').forEach(radio => {
    radio.addEventListener("change", function() {
      updateSideBG2Fields();
      updateBackgroundModifiers();
    });
  });

  // Attach form submission listener for final race value and side BG bonus validation.
  document.getElementById("characterForm").addEventListener("submit", function(e) {
    if (!validateSideBackgroundBonusTypes()) {
      e.preventDefault();
    }
    let finalRaceValue = (document.getElementById("subrace-container").style.display !== "none") ?
                         document.getElementById("subrace").value : document.getElementById("race").value;
    document.getElementById("finalRace").value = finalRaceValue;
  });

  // Racial customizable bonus check.
function checkForCustomizable() {
  const mainCode = raceEl.value;
  const subCode  = (subraceContainer.style.display !== 'none' && subraceEl.value)
                   ? subraceEl.value
                   : null;

  // 1) find the parent race entry
  const parent = races.find(r => r.code === mainCode);
  if (!parent) {
    console.warn("No race found for code", mainCode);
    document.getElementById("racial-allocation-section").style.display = "none";
    return;
  }
// start with parent race free_points
const racePts    = parent.free_points || 0;

// add subrace free_points if any
let subracePts = 0;
if (subCode) {
  const sub = parent.subraces.find(sr => sr.code === subCode);
  if (sub && typeof sub.free_points === 'number') {
    subracePts = sub.free_points;
  }
}

// combined pool
const freePts = racePts + subracePts;

  // 2) get freePts either from the parent or from the selected subrace


  // 3) show/hide the section
  const section = document.getElementById("racial-allocation-section");
  if (freePts > 0) {
    racialASIPoints = freePts;
    document.getElementById("racial-points").innerText = racialASIPoints;
    section.style.display = "";

    // 4) set each input's max to (max_bonus_per_ability − fixed racial bonus)
    //    adjust `maxPer` if you want per-subrace caps
    const maxPer = parent.max_bonus_per_ability;
    ["Strength","Dexterity","Constitution","Intelligence","Wisdom","Charisma"]
      .forEach(stat => {
        // find how much the race (or subrace) already gives you
        const fixed = (racialModifiersDict[subCode||mainCode][stat]||0);
        const fld   = document.getElementById("racial-" + stat.toLowerCase());
        fld.max     = Math.max(maxPer - fixed, 0);
      });
  } else {
    section.style.display = "none";
  }
}


  raceEl.addEventListener("change",  checkForCustomizable);
  subraceEl.addEventListener("change", checkForCustomizable);


  // Apply customizable racial allocation.
  function applyRacialAllocation() {
    const inputs = ["racial-strength", "racial-dexterity", "racial-constitution", "racial-intelligence", "racial-wisdom", "racial-charisma"];
    let total = 0;
    for (let id of inputs) {
      let val = Number(document.getElementById(id).value);
      if (val > 1) {
        alert("Each ability can receive a maximum of +1.");
        return;
      }
      total += val;
    }
    const mainCode  = raceEl.value;
    const subCode   = (subraceContainer.style.display !== 'none' && subraceEl.value)
                    ? subraceEl.value
                    : null;

    // look up their free_points (or 0 if none)
    const racePts    = customizableRaces[mainCode]  || 0;
    const subracePts = subCode
                    ? (customizableRaces[subCode] || 0)
                    : 0;

    // combined budget
    const allowed = racePts + subracePts;
    if (total !== allowed) {
      alert("Please allocate exactly " + allowed + " bonus point(s).");
      return;
    }
    racialASIBonus["Strength"] = Number(document.getElementById("racial-strength").value);
    racialASIBonus["Dexterity"] = Number(document.getElementById("racial-dexterity").value);
    racialASIBonus["Constitution"] = Number(document.getElementById("racial-constitution").value);
    racialASIBonus["Intelligence"] = Number(document.getElementById("racial-intelligence").value);
    racialASIBonus["Wisdom"] = Number(document.getElementById("racial-wisdom").value);
    racialASIBonus["Charisma"] = Number(document.getElementById("racial-charisma").value);
    updateDisplay();
    alert("Racial bonuses applied!");
  }

  // Update half-elf origin display.
  function updateHalfElfOriginDisplay() {
  const raceValue = (document.getElementById("subrace-container").style.display !== "none")
    ? document.getElementById("subrace").value
    : document.getElementById("race").value;
  const container = document.getElementById("half-elf-origin-container");
  const select    = document.getElementById("half-elf-origin");
  if (raceValue === "half_elf_fully") {
    container.style.display = "block";
    select.disabled = false;
  } else {
    container.style.display = "none";
    select.disabled = true;
    select.value = "";    // clear any leftover value
  }
}


  // Update main display: stats table, hidden inputs, and stage transitions.
  function updateDisplay() {
    updateBackgroundModifiers();
    const effectiveModifiers = getCurrentRacialModifiers() || {};
    document.getElementById("points-remaining").innerText = pointsRemaining;
    document.getElementById("boosts-remaining").innerText = boostsRemaining;
    document.getElementById("background-total").innerText =
      Object.values(backgroundModifiers).reduce((a, b) => a + b, 0);
// Only advance to Boosts (step=4) once Point‑Buy, Race & Background are done:
const raceChosen = !!document.getElementById("race").value;
const bgChosen   = !!document.getElementById("main_background").value;
const bgOK       = Object.values(backgroundModifiers).reduce((a, b) => a + b, 0) >= 3;
const pbOK       = pointsRemaining === 0;

step = (pbOK && raceChosen && bgChosen && bgOK) ? 4 : 1;

    let tableContent = "";
    stats.forEach(stat => {
      let base = baseStats[stat];
      let fixedRace = effectiveModifiers[stat] || 0;
      let bgMod = backgroundModifiers[stat] || 0;
      let boostMod = boostModifiers[stat] || 0;
      let finalValue = base + fixedRace + bgMod + boostMod;
      tableContent += `
        <tr>
          <td>${stat}</td>
          <td>
            <button type="button"
        onclick="adjustStat('${stat}', 1)"
        ${step === 4 ? 'disabled' : ''}>+</button>

            ${base}
<button type="button"
        onclick="adjustStat('${stat}', -1)"
        ${step === 4 || base <= 8 ? 'disabled' : ''}>-</button>
          </td>
          <td>${fixedRace}</td>
          <td>${bgMod}</td>
          <td>
            <button type="button" onclick="applyBoost('${stat}', 3)" ${step < 4 || boostedStats[stat] ? 'disabled' : ''}>+3</button>
            <button type="button" onclick="applyBoost('${stat}', 2)" ${step < 4 || boostedStats[stat] ? 'disabled' : ''}>+2</button>
            <button type="button" onclick="applyBoost('${stat}', 1)" ${step < 4 || boostedStats[stat] ? 'disabled' : ''}>+1</button>
            ${boostMod}
          </td>
          <td>${finalValue}</td>
        </tr>
      `;
    });
    document.getElementById("stat-table").innerHTML = tableContent;
    document.getElementById("strengthInput").value = baseStats["Strength"] + (effectiveModifiers["Strength"] || 0) + (backgroundModifiers["Strength"] || 0);
    document.getElementById("dexterityInput").value = baseStats["Dexterity"] + (effectiveModifiers["Dexterity"] || 0) + (backgroundModifiers["Dexterity"] || 0);
    document.getElementById("constitutionInput").value = baseStats["Constitution"] + (effectiveModifiers["Constitution"] || 0) + (backgroundModifiers["Constitution"] || 0);
    document.getElementById("intelligenceInput").value = baseStats["Intelligence"] + (effectiveModifiers["Intelligence"] || 0) + (backgroundModifiers["Intelligence"] || 0);
    document.getElementById("wisdomInput").value = baseStats["Wisdom"] + (effectiveModifiers["Wisdom"] || 0) + (backgroundModifiers["Wisdom"] || 0);
    document.getElementById("charismaInput").value = baseStats["Charisma"] + (effectiveModifiers["Charisma"] || 0) + (backgroundModifiers["Charisma"] || 0);
    if (document.getElementById("racial-allocation-section").style.display !== "none") {
      document.getElementById("racial-points").innerText = racialASIPoints;
    }
  }

  // Apply boosts.
  function applyBoost(stat, value) {
    if (step < 4 || boostedStats[stat]) return;
    if (boostsRemaining <= 0) return;
    let currentScore = baseStats[stat] + (getCurrentRacialModifiers()[stat] || 0) + (backgroundModifiers[stat] || 0);
    if (value === 2 && currentScore >= 14 && currentScore <= 17) {
      if (highBoostedUsed || boostsRemaining < 2) return;
      boostModifiers[stat] += 2;
      boostsRemaining -= 2;
      highBoostedUsed = true;
    } else if (value === 1 && currentScore >= 14) {
      if (currentScore + 1 > 19) return;
      boostModifiers[stat] += 1;
      boostsRemaining--;
    } else if (value === 2 && currentScore <= 13) {
      boostModifiers[stat] += 2;
      boostsRemaining--;
    } else if (value === 3 && currentScore <= 10) {
      boostModifiers[stat] += 3;
      boostsRemaining--;
    } else {
      return;
    }
    boostedStats[stat] = true;
    updateDisplay();
  }

  // Get current effective racial modifiers.
  function getCurrentRacialModifiers() {
    const mainRace = document.getElementById("race").value;
    const subraceContainer = document.getElementById("subrace-container");
    let baseMods;
    if (subraceContainer && subraceContainer.style.display !== "none") {
    const subraceValue = document.getElementById("subrace").value;
    if (subraceValue) {
      if (mainRace === "half_elf") {
        const defaultBonus = racialModifiersDict["half_elf"] || { "Strength": 0, "Dexterity": 1, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 1 };
        const subBonus = racialModifiersDict[subraceValue] || { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
        baseMods = {
          "Strength": defaultBonus["Strength"] + subBonus["Strength"],
          "Dexterity": defaultBonus["Dexterity"] + subBonus["Dexterity"],
          "Constitution": defaultBonus["Constitution"] + subBonus["Constitution"],
          "Intelligence": defaultBonus["Intelligence"] + subBonus["Intelligence"],
          "Wisdom": defaultBonus["Wisdom"] + subBonus["Wisdom"],
          "Charisma": defaultBonus["Charisma"] + subBonus["Charisma"]
        };
      } else {
        baseMods = racialModifiersDict[subraceValue] || { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
      }
    } else {
      // No subrace selected: fall back to main race modifiers.
      baseMods = racialModifiersDict[mainRace] || { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
    }
  } else {
    baseMods = racialModifiersDict[mainRace] || { "Strength": 0, "Dexterity": 0, "Constitution": 0, "Intelligence": 0, "Wisdom": 0, "Charisma": 0 };
  }

    if (customizableRaces.hasOwnProperty(mainRace) || (mainRace === "half_elf" && (document.getElementById("subrace").value === "half_elf_human_dominated" || document.getElementById("subrace").value === "half_elf_fully"))) {
      return {
        "Strength": (baseMods["Strength"] || 0) + (racialASIBonus["Strength"] || 0),
        "Dexterity": (baseMods["Dexterity"] || 0) + (racialASIBonus["Dexterity"] || 0),
        "Constitution": (baseMods["Constitution"] || 0) + (racialASIBonus["Constitution"] || 0),
        "Intelligence": (baseMods["Intelligence"] || 0) + (racialASIBonus["Intelligence"] || 0),
        "Wisdom": (baseMods["Wisdom"] || 0) + (racialASIBonus["Wisdom"] || 0),
        "Charisma": (baseMods["Charisma"] || 0) + (racialASIBonus["Charisma"] || 0)
      };
    }
    return baseMods;
  }

  // Setup for combo changes.
  document.querySelectorAll('input[name="bg_combo"]').forEach(radio => {
    radio.addEventListener("change", function() {
      const combo = parseInt(this.value, 10);
      document.getElementById("side_bg1_container").style.display = (combo >= 1) ? "block" : "none";
      document.getElementById("side_bg2_container").style.display = (combo === 2) ? "block" : "none";
      if (combo === 2) {
        setupSideBG1ForCombo2();
      }
      updateBackgroundModifiers();
    });
  });

  // Other background-related dropdown listeners.
  const sideBg1Ability = document.getElementById("side_bg1_ability_choice");
if (sideBg1Ability) {
  sideBg1Ability.addEventListener("change", updateBackgroundModifiers);
}

const sideBg1Skill = document.getElementById("side_bg1_skill_choice");
if (sideBg1Skill) {
  sideBg1Skill.addEventListener("change", updateBackgroundModifiers);
}

const sideBg2Ability = document.getElementById("side_bg2_ability_choice");
if (sideBg2Ability) {
  sideBg2Ability.addEventListener("change", updateBackgroundModifiers);
}

const sideBg2Skill = document.getElementById("side_bg2_skill_choice");
if (sideBg2Skill) {
  sideBg2Skill.addEventListener("change", updateBackgroundModifiers);
}
document.getElementById("characterForm").addEventListener("submit", function () {
  const skillMap = {};
  for (let skill in bgSkillProficiencies) {
    if (bgSkillProficiencies[skill]) {
      skillMap[skill] = "Trained";
    }
  }
  document.getElementById("computed_skill_proficiencies").value = JSON.stringify(skillMap);
});



  // Finalize background validation on form submission.
  document.getElementById("characterForm").addEventListener("submit", function(e) {
    if (!validateSideBackgroundBonusTypes()) {
      e.preventDefault();
    }
  });

  // Update race dropdown display with modifier info.
  const raceDropdown = document.getElementById("race");
  for (let i = 0; i < raceDropdown.options.length; i++) {
    let option = raceDropdown.options[i];
    if (!option.value) continue;
    if (racialModifiersDict[option.value]) {
      const mods = racialModifiersDict[option.value];
      option.text = `${option.text} (Str: ${mods.Strength}, Dex: ${mods.Dexterity}, Con: ${mods.Constitution}, Int: ${mods.Intelligence}, Wis: ${mods.Wisdom}, Cha: ${mods.Charisma})`;
    }
  }

  // Update background dropdown display.
  const mainBgDropdown = document.getElementById("main_background");
  for (let i = 0; i < mainBgDropdown.options.length; i++) {
    let option = mainBgDropdown.options[i];
    if (option.value && backgrounds[option.value]) {
      let bg = backgrounds[option.value];
      option.text = `${option.text} (+${bg.primary.bonus} ${bg.primary.ability}, +${bg.secondary.bonus} ${bg.secondary.ability} / Skills: ${bg.primary.skill}, ${bg.secondary.skill})`;
    }
  }
  const sideBgDropdowns = [document.getElementById("side_background_1"), document.getElementById("side_background_2")];
  sideBgDropdowns.forEach(dropdown => {
    for (let i = 0; i < dropdown.options.length; i++) {
      let option = dropdown.options[i];
      if (option.value && backgrounds[option.value]) {
        let bg = backgrounds[option.value];
        option.text = `${option.text} (+${bg.primary.bonus} ${bg.primary.ability}, +${bg.secondary.bonus} ${bg.secondary.ability} / Skills: ${bg.primary.skill}, ${bg.secondary.skill})`;
      }
    }
  });

  // Initial call to update background summary.
  window.adjustStat = adjustStat;
window.applyBoost = applyBoost;
window.resetBackground = resetBackground;
window.resetBoosts = resetBoosts;
window.resetCharacter = resetCharacter;
window.applyRacialAllocation = applyRacialAllocation;

  updateBackgroundSummary();
  checkForCustomizable();
});
</script>

{% endblock %}
